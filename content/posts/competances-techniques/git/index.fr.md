---
title: "Compétence Technique : Maîtrise de l'outil de gestion de version Git"
date: 2025-03-08T08:06:25+06:00
menu:
  sidebar:
    name: Compétences Git
    identifier: git
    parent: technique
    weight: 28
---

# Maîtrise de Git : De Mes Débuts Personnels à la Collaboration en Entreprise

L'outil de gestion de versions Git est devenu essentiel dans le développement logiciel moderne. Bien plus qu'un simple système de sauvegarde, aide à mieux travailler ensemble et garde un historique de l'évolution du projet. J'ai commencé à utiliser Git bien avant mes études, sur de petits projets personnels, et cette compétence s'est renforcée avec mes expériences à l'école et au travail, au point que je l'utilise quotidiennement.

## Ma Définition Personnelle et l'Importance de Git

Pour moi, Git n'est pas juste un outil technique, mais une façon de travailler ensemble avec rigueur. Il permet de bien organiser l'historique d'un projet, de travailler sur des parties séparées pour éviter les problèmes, et de rassembler le travail de chacun de façon logique. Dans mon travail actuel, bien connaître Git est très important. Ça permet de suivre facilement toutes les modifications, de simplifier les relectures de code et de garder un code propre, même quand on est plusieurs à travailler dessus. C'est une compétence de base qui aide à développer plus efficacement et avec une meilleure qualité. Elle est si importante que je pense qu'elle est obligatoire pour tout développeur qui veut bien progresser sur de gros projets.

## Comment je l'Utilise : Preuves de Maîtrise au Quotidien

Ma connaissance de Git n'est pas seulement théorique ; elle se voit dans ma façon de travailler sur chaque étape du développement. Ces compétences viennent d'une pratique régulière, autant sur mes propres projets que sur des projets d'entreprise plus complexes.

### Les Bases Solides : Du Commit aux Pull Requests

Depuis que j'ai commencé à l'utiliser, les commandes de base de Git (`commit`, `push`, `pull`, `branch`, `checkout`) sont devenues naturelles pour moi. En plus de ces bases, je suis assez à l'aise avec des opérations plus compliquées mais très utiles pour travailler proprement et efficacement :

* La fusion de branches (`merge`) : Je l'utilise souvent pour ajouter des fonctionnalités terminées aux branches principales, en faisant attention à ce que l'historique reste clair.
* Le rebasage (`rebase`) : Je préfère souvent le `rebase` pour garder un historique simple et propre avant de soumettre mes modifications avec une Pull Request, ce qui aide à la relecture et à la compréhension du travail.
* Résoudre les conflits : Ça arrive souvent quand on travaille en équipe. Je sais analyser et résoudre les conflits de fusion pas à pas, en comprenant d'où viennent les différences et en faisant les changements qu'il faut pour que le code reste correct.
* Les Pull Requests (PR) / Merge Requests (MR) : C'est principalement comme ça que je contribue au travail en entreprise. Je fais très attention à ce que les descriptions de mes PRs soient claires, en expliquant pourquoi et comment j'ai fait les changements, pour que la relecture par mes collègues soit plus simple.

### Travailler Ensemble de Manière Structurée et Suivre les Règles

Travailler en équipe sur de gros projets m'a appris que c'est très important d'être rigoureux quand on utilise Git :

* Bien gérer les branches : J'ai l'habitude de créer et de gérer mes propres branches pour les fonctionnalités (`feature branches`), en suivant bien les règles de nommage de l'entreprise. Ça permet de mieux organiser le projet et de comprendre facilement où en sont les différents développements.
* Comprendre et utiliser les Conventional Commits : Dans mon entreprise, on utilise les règles des Conventional Commits ([https://www.conventionalcommits.org/en/v1.0.0/](https://www.conventionalcommits.org/en/v1.0.0/)). J'ai totalement adopté cette façon de faire tous les jours. Chaque `commit` est précédé d'un type (`feat`, `fix`, `docs`, `style`, `refactor`, `test`, `chore`, etc.) et peut avoir une portée (scope) ainsi qu'un `footer` pour les `breaking changes` ou pour lier à des tickets de gestion de projet. Cette façon de faire donne un historique Git très propre, facile à lire et à analyser automatiquement, ce qui aide à créer des listes de changements automatiquement et à comprendre vite comment le projet a évolué.

### Techniques Avancées pour Être Plus Efficace

Ma curiosité et les besoins de certains projets m'ont poussé à apprendre et à utiliser des aspects de Git plus avancés :

* Le `cherry-picking` : J'ai déjà utilisé cette commande pour prendre des commits précis d'une branche et les mettre sur une autre, par exemple pour corriger un bug urgent sur la branche de production sans prendre tout le reste d'une branche de développement, ou pour récupérer un changement précis d'une branche qu'on n'utilise plus. Cette technique, quand on l'utilise bien, est très utile pour gérer les changements avec précision.

Toutes ces compétences ensemble montrent que je sais utiliser Git pas seulement pour gérer les versions, mais aussi pour vraiment améliorer la qualité du logiciel et aider à mieux travailler en équipe.

## Mon Bilan Critique sur Ma Maîtrise de Git

Je pense avoir un bon niveau de Git pour les choses qu'on fait tous les jours et pour les situations de travail en équipe plus compliquées qu'on voit souvent en entreprise. Comme je comprends comment Git fonctionne à l'intérieur, je peux résoudre la plupart des problèmes et choisir la meilleure façon de gérer les branches et les fusions selon la situation.

* Points forts et points à améliorer : La rigueur que j'ai apprise avec les Conventional Commits et la bonne gestion des branches est un vrai plus. Je peux adapter ma façon d'utiliser Git aux habitudes de n'importe quelle équipe. Je pourrais encore m'améliorer en explorant plus en détail les commandes "internes" de Git (les commandes de bas niveau), pas tant pour les utiliser tous les jours mais pour comprendre encore mieux comment il marche. Je pourrais aussi regarder de plus près comment écrire des scripts Git personnalisés ou utiliser les hooks Git de manière avancée pour faire certaines tâches automatiquement.
* Est-ce que ça marche partout ? : Pour développer des applications, des sites web ou des applis mobiles, ce que je sais faire avec Git est solide et marche dans presque toutes les situations. Pour des cas très particuliers comme la gestion de très gros projets uniques (monorepos) avec des historiques très compliqués, il pourrait y avoir des difficultés en plus, mais j'ai de bonnes bases pour y faire face.
* Place dans mon profil et mes responsabilités : Cette compétence est très importante dans mon profil de développeur. C'est la base de mes contributions techniques et de ma capacité à bien m'intégrer dans une équipe de développement. J'ai appris petit à petit, en commençant par apprendre tout seul puis beaucoup plus vite en pratiquant en entreprise et parce que je devais travailler avec d'autres.
* Mon avis et conseil : Avec mon expérience, je conseille toujours de faire en sorte que l'historique Git soit clair et propre. Un historique bien fait fait gagner beaucoup de temps à toute l'équipe, que ce soit pour trouver des bugs, relire du code ou comprendre comment une fonctionnalité a changé. Adopter des règles comme les Conventional Commits, c'est, pour moi, un petit effort pour un gros avantage pour que le projet soit plus facile à maintenir.

## Mon Projet Professionnel et l'Avenir de Git

Ma maîtrise de Git est une compétence fondamentale pour mon projet professionnel, mais elle n'est pas une fin en soi. Au lieu de simplement me demander comment je peux continuer à m'améliorer, une question plus large et plus intéressante se pose : comment Git lui-même va-t-il évoluer dans les années à venir ?

Avec l'intégration de plus en plus poussée de l'intelligence artificielle dans nos outils, peut-on imaginer un futur où Git deviendrait plus "intelligent" ? Un assistant qui pourrait, par exemple, analyser les changements dans le code pour proposer des messages de commit pertinents et standardisés, ou même aider à résoudre des conflits de fusion complexes de manière quasi automatique.

À l'inverse, est-ce que l'outil va tendre vers une plus grande abstraction ? Un futur où les développeurs interagiront de moins en moins directement avec les commandes, celles-ci étant entièrement gérées par des interfaces graphiques et des processus automatisés si intuitifs que la complexité de Git deviendrait invisible au quotidien.

La réponse n'est pas encore claire. Mais une chose est certaine, la prochaine étape pour faire évoluer ma compétence ne sera pas seulement d'apprendre de nouvelles commandes, mais de rester attentif à ces transformations, de les expérimenter et de comprendre comment elles redéfiniront la collaboration entre développeurs. Ma relation avec Git n'est donc plus seulement celle d'un utilisateur, mais aussi celle d'un observateur curieux de son futur.
